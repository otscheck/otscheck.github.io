<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Principe L - Substitution de Liskov</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Particules flottantes -->
  <div class="particle" style="left: 18%; animation-delay: 1.5s;"></div>
  <div class="particle" style="left: 28%; animation-delay: 3.5s;"></div>
  <div class="particle" style="left: 38%; animation-delay: 5.5s;"></div>
  <div class="particle" style="left: 48%; animation-delay: 7.5s;"></div>
  <div class="particle" style="left: 58%; animation-delay: 9.5s;"></div>
  <div class="particle" style="left: 68%; animation-delay: 11.5s;"></div>
  <div class="particle" style="left: 78%; animation-delay: 13.5s;"></div>

  <!-- Formes géométriques -->
  <div class="shape square" style="top: 35%; left: 15%;"></div>
  <div class="shape circle" style="top: 75%; right: 18%;"></div>
  <div class="shape triangle" style="top: 55%; left: 85%;"></div>
  <div class="shape square" style="top: 40%; right: 12%;"></div>

  <a href="../index.html" class="back-link">&larr; Retour</a>
  <header>
    <h1>Substitution de Liskov</h1>
  </header>

  <main>
    <section>
      <h2>Définition</h2>
      <p>Si S est un sous-type de T, alors les objets de type T peuvent être remplacés par des objets de type S sans altérer les propriétés souhaitables du programme.</p>
      <p>En d'autres termes, une classe dérivée doit pouvoir remplacer sa classe de base sans casser le comportement attendu.</p>

      <h2>Pourquoi c'est important ?</h2>
      <p>Ce principe garantit que l'héritage est utilisé correctement et que le polymorphisme fonctionne comme attendu. Il évite les surprises comportementales lors de l'utilisation du polymorphisme.</p>

      <h2>Exemple qui viole le principe</h2>
      <pre><code>// Violation du principe Liskov
class Rectangle {
  constructor(protected largeur: number, protected hauteur: number) {}

  setLargeur(largeur: number) {
    this.largeur = largeur;
  }

  setHauteur(hauteur: number) {
    this.hauteur = hauteur;
  }

  getAire(): number {
    return this.largeur * this.hauteur;
  }
}

class Carre extends Rectangle {
  setLargeur(largeur: number) {
    super.setLargeur(largeur);
    super.setHauteur(largeur); // Problème !
  }

  setHauteur(hauteur: number) {
    super.setHauteur(hauteur);
    super.setLargeur(hauteur); // Problème !
  }
}

// Code client qui s'attend à un comportement normal
function agrandirRectangle(rect: Rectangle) {
  rect.setLargeur(5);
  rect.setHauteur(10);
  console.log(rect.getAire()); // Devrait être 50, mais...
}

// Problème !
const carre = new Carre(0, 0);
agrandirRectangle(carre); // Aire = 100 au lieu de 50 !</code></pre>

      <h2>Exemple corrigé (SOLID)</h2>
      <pre><code>// Solution respectant Liskov
interface Forme {
  getAire(): number;
}

class Rectangle implements Forme {
  constructor(protected largeur: number, protected hauteur: number) {}

  setLargeur(largeur: number) {
    this.largeur = largeur;
  }

  setHauteur(hauteur: number) {
    this.hauteur = hauteur;
  }

  getAire(): number {
    return this.largeur * this.hauteur;
  }
}

class Carre implements Forme {
  constructor(private cote: number) {}

  setCote(cote: number) {
    this.cote = cote;
  }

  getAire(): number {
    return this.cote * this.cote;
  }
}

// Maintenant ça fonctionne correctement
function calculerAire(forme: Forme): number {
  return forme.getAire();
}

const rectangle = new Rectangle(5, 10);
const carre = new Carre(5);

console.log(calculerAire(rectangle)); // 50
console.log(calculerAire(carre)); // 25</code></pre>

      <h2>Comment vérifier le respect du principe ?</h2>
      <p>Pour vérifier que vos classes respectent LSP, posez-vous ces questions :</p>
      <ul>
        <li>✅ Les préconditions de la classe dérivée sont-elles plus faibles ?</li>
        <li>✅ Les postconditions de la classe dérivée sont-elles plus fortes ?</li>
        <li>✅ Les invariants de la classe de base sont-ils préservés ?</li>
        <li>✅ Le comportement est-il identique du point de vue du client ?</li>
      </ul>

      <h2>Avantages</h2>
      <ul>
        <li>✅ Polymorphisme prévisible et fiable</li>
        <li>✅ Code plus maintenable et testable</li>
        <li>✅ Évite les bugs subtils liés à l'héritage</li>
        <li>✅ Améliore la conception orientée objet</li>
      </ul>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Otscheck. Code sobre, solide, utile, mobile.</p>
  </footer>
</body>
</html>

      <h2>Exemple qui viole le principe</h2>

      <pre><code>// Violation du principe Liskov
class Rectangle {
  constructor(protected largeur: number, protected hauteur: number) {}

  setLargeur(largeur: number) {
    this.largeur = largeur;
  }

  setHauteur(hauteur: number) {
    this.hauteur = hauteur;
  }

  getAire(): number {
    return this.largeur * this.hauteur;
  }
}

class Carre extends Rectangle {
  setLargeur(largeur: number) {
    super.setLargeur(largeur);
    super.setHauteur(largeur); // Problème !
  }

  setHauteur(hauteur: number) {
    super.setHauteur(hauteur);
    super.setLargeur(hauteur); // Problème !
  }
}

// Code client qui s'attend à un comportement normal
function agrandirRectangle(rect: Rectangle) {
  rect.setLargeur(5);
  rect.setHauteur(10);
  console.log(rect.getAire()); // Devrait être 50, mais...
}

// Problème !
const carre = new Carre(0, 0);
agrandirRectangle(carre); // Aire = 100 au lieu de 50 !</code></pre>

      <h2>Exemple corrigé (SOLID)</h2>

      <pre><code>// Solution respectant Liskov
interface Forme {
  getAire(): number;
}

class Rectangle implements Forme {
  constructor(protected largeur: number, protected hauteur: number) {}

  setLargeur(largeur: number) {
    this.largeur = largeur;
  }

  setHauteur(hauteur: number) {
    this.hauteur = hauteur;
  }

  getAire(): number {
    return this.largeur * this.hauteur;
  }
}

class Carre implements Forme {
  constructor(private cote: number) {}

  setCote(cote: number) {
    this.cote = cote;
  }

  getAire(): number {
    return this.cote * this.cote;
  }
}

// Maintenant ça fonctionne correctement
function calculerAire(forme: Forme): number {
  return forme.getAire();
}

const rectangle = new Rectangle(5, 10);
const carre = new Carre(5);

console.log(calculerAire(rectangle)); // 50
console.log(calculerAire(carre)); // 25</code></pre>

      <h2>Comment vérifier le respect du principe ?</h2>

      <p>Pour vérifier que vos classes respectent LSP, posez-vous ces questions :</p>

      <ul>
        <li>✅ Les préconditions de la classe dérivée sont-elles plus faibles ?</li>
        <li>✅ Les postconditions de la classe dérivée sont-elles plus fortes ?</li>
        <li>✅ Les invariants de la classe de base sont-ils préservés ?</li>
        <li>✅ Le comportement est-il identique du point de vue du client ?</li>
      </ul>

      <h2>Avantages</h2>

      <ul>
        <li>✅ Polymorphisme prévisible et fiable</li>
        <li>✅ Code plus maintenable et testable</li>
        <li>✅ Évite les bugs subtils liés à l'héritage</li>
        <li>✅ Améliore la conception orientée objet</li>
      </ul>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Otscheck. Code sobre, solide, utile, mobile.</p>
  </footer>
</body>

</html>
