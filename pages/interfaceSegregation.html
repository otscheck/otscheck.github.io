<!DOCTYPE   <link rel="stylesheet" href="../style.css">
</head>

<body>
  <!-- Les particules et formes seront générées automatiquement par layout.js -->
  <!-- Le contenu sera généré automatiquement par content.js -->

  <script src="../layout.js"></script>
  <script src="../content.js"></script>ng="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Principe I - Ségrégation des Interfaces</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style.css">
</head>

<body>
  <!-- Particules flottantes -->
  <div class="particle" style="left: 14%; animation-delay: 2s;"></div>
  <div class="particle" style="left: 24%; animation-delay: 4s;"></div>
  <div class="particle" style="left: 34%; animation-delay: 6s;"></div>
  <div class="particle" style="left: 44%; animation-delay: 8s;"></div>
  <div class="particle" style="left: 54%; animation-delay: 10s;"></div>
  <div class="particle" style="left: 64%; animation-delay: 12s;"></div>
  <div class="particle" style="left: 74%; animation-delay: 14s;"></div>
  <div class="particle" style="left: 84%; animation-delay: 16s;"></div>

  <!-- Formes géométriques -->
  <div class="shape circle" style="top: 28%; left: 25%;"></div>
  <div class="shape triangle" style="top: 68%; right: 22%;"></div>
  <div class="shape square" style="top: 48%; left: 78%;"></div>
  <div class="shape circle" style="top: 38%; right: 15%;"></div>

  <a href="index.html" class="back-link">&larr; Retour</a>
  <header>
    <h1>Ségrégation des Interfaces</h1>
  </header>

  <main>
    <section>
      <h2>Définition</h2>

      <p>Un client ne devrait pas être forcé d'implémenter une interface qu'il n'utilise pas, ou dépendre de méthodes qu'il n'utilise pas.</p>

      <p>Il vaut mieux avoir plusieurs interfaces spécifiques plutôt qu'une seule interface générale.</p>

      <h2>Pourquoi c'est important ?</h2>

      <p>Ce principe évite la dépendance à du code inutile et réduit le couplage entre les composants. Il favorise des interfaces plus petites et plus ciblées.</p>

      <h2>Exemple qui viole le principe</h2>

      <pre><code>// Violation du principe ISP
interface MachineMultifonction {
  imprimer(document: string): void;
  scanner(document: string): string;
  faxer(document: string, numero: string): void;
  photocopier(document: string): string;
}

// Problème : une simple imprimante doit implémenter tout !
class ImprimanteSimple implements MachineMultifonction {
  imprimer(document: string): void {
    console.log(`Impression: ${document}`);
  }

  scanner(document: string): string {
    throw new Error("Cette imprimante ne scanne pas !");
  }

  faxer(document: string, numero: string): void {
    throw new Error("Cette imprimante ne faxe pas !");
  }

  photocopier(document: string): string {
    throw new Error("Cette imprimante ne photocopie pas !");
  }
}</code></pre>

      <h2>Exemple corrigé (SOLID)</h2>

      <pre><code>// Solution respectant ISP
interface Imprimante {
  imprimer(document: string): void;
}

interface Scanner {
  scanner(document: string): string;
}

interface Fax {
  faxer(document: string, numero: string): void;
}

interface Photocopieur {
  photocopier(document: string): string;
}

// Maintenant chaque classe n'implémente que ce dont elle a besoin
class ImprimanteSimple implements Imprimante {
  imprimer(document: string): void {
    console.log(`Impression: ${document}`);
  }
}

class ScannerSimple implements Scanner {
  scanner(document: string): string {
    return `Scan de: ${document}`;
  }
}

class MachineMultifonction implements Imprimante, Scanner, Fax, Photocopieur {
  imprimer(document: string): void {
    console.log(`Impression: ${document}`);
  }

  scanner(document: string): string {
    return `Scan de: ${document}`;
  }

  faxer(document: string, numero: string): void {
    console.log(`Fax de ${document} vers ${numero}`);
  }

  photocopier(document: string): string {
    return `Photocopie de: ${document}`;
  }
}

// Utilisation flexible
function utiliserImprimante(imprimante: Imprimante) {
  imprimante.imprimer("Document important");
}

function utiliserScanner(scanner: Scanner) {
  const resultat = scanner.scanner("Document à scanner");
  return resultat;
}

const imprimante = new ImprimanteSimple();
const machine = new MachineMultifonction();

utiliserImprimante(imprimante); // ✅ Fonctionne
utiliserImprimante(machine);    // ✅ Fonctionne aussi
utiliserScanner(machine);       // ✅ Fonctionne</code></pre>

      <h2>Avantages</h2>

      <ul>
        <li>✅ Interfaces plus petites et plus cohérentes</li>
        <li>✅ Moins de couplage entre les composants</li>
        <li>✅ Code plus maintenable et testable</li>
        <li>✅ Évite l'implémentation de méthodes inutiles</li>
        <li>✅ Facilite la composition et l'injection de dépendances</li>
      </ul>

      <h2>Quand appliquer ce principe ?</h2>

      <p>Appliquez ISP lorsque :</p>

      <ul>
        <li>Vous avez des interfaces avec beaucoup de méthodes</li>
        <li>Certains clients n'utilisent qu'une partie des méthodes</li>
        <li>Vous voulez créer des composants modulaires</li>
        <li>Vous utilisez l'injection de dépendances</li>
      </ul>

      <h2>Interface vs Classe Abstraite</h2>

      <p>Une alternative aux interfaces multiples peut être l'utilisation de classes abstraites avec des méthodes par défaut, mais les interfaces restent souvent préférables pour leur flexibilité.</p>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Otscheck. Code sobre, solide, utile, mobile.</p>
  </footer>
</body>

</html>
